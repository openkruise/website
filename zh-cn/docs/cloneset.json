{
  "filename": "cloneset.md",
  "__html": "<h1>CloneSet</h1>\n<p>CloneSet 控制器提供了高效管理无状态应用的能力，它可以对标原生的 <code>Deployment</code>，但 <code>CloneSet</code> 提供了很多增强功能。</p>\n<p>按照 Kruise 的<a href=\"../blog/blog1.html\">命名规范</a>，CloneSet 是一个直接管理 Pod 的 <strong>Set</strong> 类型 workload。\n一个简单的 CloneSet yaml 文件如下：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">labels:</span>\n    <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">sample</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">selector:</span>\n    <span class=\"hljs-attr\">matchLabels:</span>\n      <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">metadata:</span>\n      <span class=\"hljs-attr\">labels:</span>\n        <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">containers:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n        <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">nginx:alpine</span>\n</code></pre>\n<h2>扩缩容功能</h2>\n<h3>支持 PVC 模板</h3>\n<p>CloneSet 允许用户配置 PVC 模板 <code>volumeClaimTemplates</code>，用来给每个 Pod 生成独享的 PVC，这是 <code>Deployment</code> 所不支持的。\n如果用户没有指定这个模板，CloneSet 会创建不带 PVC 的 Pod。</p>\n<p>一些注意点：</p>\n<ul>\n<li>每个被自动创建的 PVC 会有一个 ownerReference 指向 CloneSet，因此 CloneSet 被删除时，它创建的所有 Pod 和 PVC 都会被删除。</li>\n<li>每个被 CloneSet 创建的 Pod 和 PVC，都会带一个 <code>apps.kruise.io/cloneset-instance-id: xxx</code> 的 label。关联的 Pod 和 PVC 会有相同的 <strong>instance-id</strong>，且它们的名字后缀都是这个 <strong>instance-id</strong>。</li>\n<li>如果一个 Pod 被 CloneSet controller 缩容删除时，这个 Pod 关联的 PVC 都会被一起删掉。</li>\n<li>如果一个 Pod 被外部直接调用删除或驱逐时，这个 Pod 关联的 PVC 还都存在；并且 CloneSet controller 发现数量不足重新扩容时，新扩出来的 Pod 会复用原 Pod 的 <strong>instance-id</strong> 并关联原来的 PVC。</li>\n<li>当 Pod 被<strong>重建升级</strong>时，关联的 PVC 会跟随 Pod 一起被删除、新建。</li>\n<li>当 Pod 被<strong>原地升级</strong>时，关联的 PVC 会持续使用。</li>\n</ul>\n<p>以下是一个带有 PVC 模板的例子：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">labels:</span>\n    <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">sample-data</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">selector:</span>\n    <span class=\"hljs-attr\">matchLabels:</span>\n      <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">metadata:</span>\n      <span class=\"hljs-attr\">labels:</span>\n        <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">containers:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n        <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">nginx:alpine</span>\n        <span class=\"hljs-attr\">volumeMounts:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">data-vol</span>\n          <span class=\"hljs-attr\">mountPath:</span> <span class=\"hljs-string\">/usr/share/nginx/html</span>\n  <span class=\"hljs-attr\">volumeClaimTemplates:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">metadata:</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">data-vol</span>\n      <span class=\"hljs-attr\">spec:</span>\n        <span class=\"hljs-attr\">accessModes:</span> <span class=\"hljs-string\">[</span> <span class=\"hljs-string\">\"ReadWriteOnce\"</span> <span class=\"hljs-string\">]</span>\n        <span class=\"hljs-attr\">resources:</span>\n          <span class=\"hljs-attr\">requests:</span>\n            <span class=\"hljs-attr\">storage:</span> <span class=\"hljs-string\">20Gi</span>\n</code></pre>\n<h3>指定 Pod 缩容</h3>\n<p>当一个 CloneSet 被缩容时，有时候用户需要指定一些 Pod 来删除。这对于 <code>StatefulSet</code> 或者 <code>Deployment</code> 来说是无法实现的，因为 <code>StatefulSet</code> 要根据序号来删除 Pod，而 <code>Deployment</code>/<code>ReplicaSet</code> 目前只能根据控制器里定义的排序来删除。</p>\n<p>CloneSet 允许用户在缩小 <code>replicas</code> 数量的同时，指定想要删除的 Pod 名字。参考下面这个例子：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">4</span>\n  <span class=\"hljs-attr\">scaleStrategy:</span>\n    <span class=\"hljs-attr\">podsToDelete:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">sample-9m4hp</span>\n</code></pre>\n<p>当控制器收到上面这个 CloneSet 更新之后，会确保 replicas 数量为 4。如果 <code>podsToDelete</code> 列表里写了一些 Pod 名字，控制器会优先删除这些 Pod。\n对于已经被删除的 Pod，控制器会自动从 <code>podsToDelete</code> 列表中清理掉。</p>\n<p>注意：</p>\n<ul>\n<li>如果你只把 Pod 名字加到 <code>podsToDelete</code>，但没有修改 <code>replicas</code> 数量，那么控制器会先把指定的 Pod 删掉，然后再扩一个新的 Pod。</li>\n<li>如果不指定 <code>podsToDelete</code>，控制器会按照默认顺序来选择 Pod 删除：not-ready &lt; ready, unscheduled &lt; scheduled, and pending &lt; running。</li>\n</ul>\n<h2>升级功能</h2>\n<h3>原地升级</h3>\n<p>CloneSet 提供了和 <code>Advanced StatefulSet</code> 相同的 3 个升级方式，默认为 <code>ReCreate</code>：</p>\n<ul>\n<li><code>ReCreate</code>: 控制器会删除旧 Pod 和它的 PVC，然后用新版本重新创建出来。</li>\n<li><code>InPlaceIfPossible</code>: 控制器会优先尝试原地升级 Pod，如果不行再采用重建升级。目前，只有修改 <code>spec.template.metadata.*</code> 和 <code>spec.template.spec.containers[x].image</code> 这些字段才可以走原地升级。</li>\n<li><code>InPlaceOnly</code>: 控制器只允许采用原地升级。因此，用户只能修改上一条中的限制字段，如果尝试修改其他字段会被 Kruise 拒绝。</li>\n</ul>\n<p>当一个 Pod 被原地升级时，控制器会先利用 readinessGates 把 Pod status 中修改为 not-ready 状态，然后再更新 Pod spec 中的 image 字段来触发 Kubelet 重建对应的容器。\n不过这样可能存在的一个风险：有时候 Kubelet 重建容器太快，还没等到其他控制器如 endpoints-controller 感知到 Pod not-ready，可能会导致流量受损。</p>\n<p>因此我们又在原地升级中提供了 <strong>graceful period</strong> 选项，作为优雅原地升级的策略。用户如果配置了 <code>gracePeriodSeconds</code> 这个字段，控制器在原地升级的过程中会先把 Pod status 改为 not-ready，然后等一段时间（<code>gracePeriodSeconds</code>），最后再去修改 Pod spec 中的镜像版本。\n这样，就为 endpoints-controller 这些控制器留出了充足的时间来将 Pod 从 endpoints 端点列表中去除。</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">InPlaceIfPossible</span>\n    <span class=\"hljs-attr\">inPlaceUpdateStrategy:</span>\n      <span class=\"hljs-attr\">gracePeriodSeconds:</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<h3>Template 和 revision</h3>\n<p><code>spec.template</code> 中定义了当前 CloneSet 中最新的 Pod 模板。\n控制器会为每次更新过的 <code>spec.template</code> 计算一个 revision hash 值，比如针对开头的 CloneSet 例子，\n控制器会为 template 计算出 revision hash 为 <code>sample-744d4796cc</code> 并上报到 CloneSet status 中。</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">generation:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-comment\"># ...</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-comment\"># ...</span>\n<span class=\"hljs-attr\">status:</span>\n  <span class=\"hljs-attr\">observedGeneration:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">readyReplicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">updateRevision:</span> <span class=\"hljs-string\">sample-d4d4fb5bd</span>\n  <span class=\"hljs-attr\">updatedReadyReplicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">updatedReplicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<p>这里是对 CloneSet status 中的字段说明：</p>\n<ul>\n<li><code>status.replicas</code>: Pod 总数</li>\n<li><code>status.readyReplicas</code>: <strong>ready</strong> Pod 数量</li>\n<li><code>status.availableReplicas</code>: <strong>ready and available</strong> Pod 数量 (满足 <code>minReadySeconds</code>)</li>\n<li><code>status.updateRevision</code>: 最新版本的 revision hash 值</li>\n<li><code>status.updatedReplicas</code>: 最新版本的 Pod 数量</li>\n<li><code>status.updatedReadyReplicas</code>: 最新版本的 <strong>ready</strong> Pod 数量</li>\n</ul>\n<h3>Partition 分批灰度</h3>\n<p>Partition 的语义是 <strong>保留旧版本 Pod 的数量或百分比</strong>，默认为 <code>0</code>。这里的 <code>partition</code> 不表示任何 <code>order</code> 序号。</p>\n<p>如果在发布过程中设置了 <code>partition</code>:</p>\n<ul>\n<li>如果是数字，控制器会将 <code>(replicas - partition)</code> 数量的 Pod 更新到最新版本。</li>\n<li>如果是百分比，控制器会将 <code>(replicas * (100% - partition))</code> 数量的 Pod 更新到最新版本。</li>\n</ul>\n<p>比如，我们将 CloneSet 例子的 image 更新为 <code>nginx:mainline</code> 并且设置 <code>partition=3</code>。过了一会，查到的 CloneSet 如下：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">generation:</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">metadata:</span>\n      <span class=\"hljs-attr\">labels:</span>\n        <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">sample</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">containers:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">nginx:mainline</span>\n        <span class=\"hljs-attr\">imagePullPolicy:</span> <span class=\"hljs-string\">Always</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">partition:</span> <span class=\"hljs-number\">3</span>\n  <span class=\"hljs-comment\"># ...</span>\n<span class=\"hljs-attr\">status:</span>\n  <span class=\"hljs-attr\">observedGeneration:</span> <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-attr\">readyReplicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">5</span>\n  <span class=\"hljs-attr\">updateRevision:</span> <span class=\"hljs-string\">sample-56dfb978d4</span>\n  <span class=\"hljs-attr\">updatedReadyReplicas:</span> <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-attr\">updatedReplicas:</span> <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>注意 <code>status.updateRevision</code> 已经更新为 <code>sample-56dfb978d4</code> 新的值。\n由于我们设置了 <code>partition=3</code>，控制器只升级了 2 个 Pod。</p>\n<pre><code class=\"language-bash\">$ kubectl get pod -L controller-revision-hash\nNAME           READY   STATUS    RESTARTS   AGE     CONTROLLER-REVISION-HASH\nsample-chvnr   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-j6c4s   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-ns85c   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-jnjdp   1/1     Running   0          10s     sample-56dfb978d4\nsample-qqglp   1/1     Running   0          18s     sample-56dfb978d4\n</code></pre>\n<h3>MaxUnavailable 最大不可用数量</h3>\n<p>MaxUnavailable 是本次发布过程中，限制最多不可用的 Pod 数量。\n它可以设置为一个<strong>绝对值</strong>或者<strong>百分比</strong>，如果不填 Kruise 会设置为默认值 <code>20%</code>。</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">maxUnavailable:</span> <span class=\"hljs-number\">20</span><span class=\"hljs-string\">%</span>\n</code></pre>\n<h3>MaxSurge 最大弹性数量</h3>\n<p>MaxSurge 是本次发布过程中，最多能扩出来超过 <code>replicas</code> 的 Pod 数量。\n它可以设置为一个<strong>绝对值</strong>或者<strong>百分比</strong>，如果不填 Kruise 会设置为默认值 <code>0</code>。</p>\n<p>如果发布的时候设置了 maxSurge，控制器会先多扩出来 <code>maxSurge</code> 数量的 Pod（此时 Pod 总数为 <code>(replicas+maxSurge)</code>)，然后再开始发布存量的 Pod。\n然后，当新版本 Pod 数量已经满足 <code>partition</code> 要求之后，控制器会再把多余的 <code>maxSurge</code> 数量的 Pod 删除掉，保证最终的 Pod 数量符合 <code>replicas</code>。</p>\n<p>要说明的是，maxSurge 不允许配合 <code>InPlaceOnly</code> 更新模式使用。\n另外，如果是与 <code>InPlaceIfPossible</code> 策略配合使用，控制器会先扩出来 <code>maxSurge</code> 数量的 Pod，再对存量 Pod 做原地升级。</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">maxSurge:</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<h3>升级顺序</h3>\n<p>当控制器选择 Pod 做升级时，默认是有一套根据 Pod phase/conditions 的排序逻辑：\n<strong>unscheduled &lt; scheduled, pending &lt; unknown &lt; running, not-ready &lt; ready</strong>。\n在此之外，CloneSet 也提供了增强的 <code>priority</code>(优先级) 和 <code>scatter</code>(打散) 策略来允许用户自定义发布顺序。</p>\n<h4>优先级策略</h4>\n<p>这个策略定义了控制器计算 Pod 发布优先级的规则，所有需要更新的 Pod 都会通过这个优先级规则计算后排序。\n目前 <code>priority</code> 可以通过 weight(权重) 和 order(序号) 两种方式来指定。</p>\n<ul>\n<li><code>weight</code>: Pod 优先级是由所有 weights 列表中的 term 来计算 match selector 得出。如下：</li>\n</ul>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">priorityStrategy:</span>\n      <span class=\"hljs-attr\">weightPriority:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">weight:</span> <span class=\"hljs-number\">50</span>\n        <span class=\"hljs-attr\">matchSelector:</span>\n          <span class=\"hljs-attr\">matchLabels:</span>\n            <span class=\"hljs-attr\">test-key:</span> <span class=\"hljs-string\">foo</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">weight:</span> <span class=\"hljs-number\">30</span>\n        <span class=\"hljs-attr\">matchSelector:</span>\n          <span class=\"hljs-attr\">matchLabels:</span>\n            <span class=\"hljs-attr\">test-key:</span> <span class=\"hljs-string\">bar</span>\n</code></pre>\n<ul>\n<li><code>order</code>: Pod 优先级是由 orderKey 的 value 决定，这里要求对应的 value 的结尾能解析为 int 值。比如 value &quot;5&quot; 的优先级是 5，value &quot;sts-10&quot; 的优先级是 10。</li>\n</ul>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">priorityStrategy:</span>\n      <span class=\"hljs-attr\">orderPriority:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">orderedKey:</span> <span class=\"hljs-string\">some-label-key</span>\n</code></pre>\n<h4>打散策略</h4>\n<p>这个策略定义了如何将一类 Pod 打散到整个发布过程中。\n比如，针对一个 <code>replica=10</code> 的 CloneSet，我们在 3 个 Pod 中添加了 <code>foo=bar</code> 标签、并设置对应的 scatter 策略，那么在发布的时候这 3 个 Pod 会排在第 1、6、10 个发布。</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">scatterStrategy:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">foo</span>\n      <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">bar</span>\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>尽管 <code>priority</code> 和 <code>scatter</code> 策略可以一起设置，但我们强烈推荐同时只用其中一个。</li>\n<li>如果使用了 <code>scatter</code> 策略，我们强烈建议只配置一个 term （key-value）。否则，实际的打散发布顺序可能会不太好理解。</li>\n</ul>\n<p>最后要说明的是，使用上述发布顺序策略都要求对特定一些 Pod 打标，这是在 CloneSet 中没有提供的。</p>\n<h3>发布暂停</h3>\n<p>用户可以通过设置 paused 为 true 暂停发布，不过控制器还是会做 replicas 数量管理：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">updateStrategy:</span>\n    <span class=\"hljs-attr\">paused:</span> <span class=\"hljs-literal\">true</span>\n</code></pre>\n<h3>生命周期钩子</h3>\n<p>从 v0.6.1 版本开始，kruise 在 CloneSet 中新增了对 lifecycle hook 的支持。</p>\n<p>每个 CloneSet 管理的 Pod 会有明确所处的状态，在 Pod label 中的 <code>lifecycle.apps.kruise.io/state</code> 标记：</p>\n<ul>\n<li>Normal：正常状态</li>\n<li>PreparingUpdate：准备原地升级</li>\n<li>Updating：原地升级中</li>\n<li>Updated：原地升级完成</li>\n<li>PreparingDelete：准备原地升级</li>\n</ul>\n<p>而生命周期钩子，则是通过在上述状态流转中卡点，来实现原地升级前后、删除前的自定义操作（比如开关流量、告警等）。</p>\n<pre><code class=\"language-golang\"><span class=\"hljs-keyword\">type</span> LifecycleStateType <span class=\"hljs-keyword\">string</span>\n\n<span class=\"hljs-comment\">// Lifecycle contains the hooks for Pod lifecycle.</span>\n<span class=\"hljs-keyword\">type</span> Lifecycle <span class=\"hljs-keyword\">struct</span> {\n    <span class=\"hljs-comment\">// PreDelete is the hook before Pod to be deleted.</span>\n    PreDelete *LifecycleHook <span class=\"hljs-string\">`json:\"preDelete,omitempty\"`</span>\n    <span class=\"hljs-comment\">// InPlaceUpdate is the hook before Pod to update and after Pod has been updated.</span>\n    InPlaceUpdate *LifecycleHook <span class=\"hljs-string\">`json:\"inPlaceUpdate,omitempty\"`</span>\n}\n\n<span class=\"hljs-keyword\">type</span> LifecycleHook <span class=\"hljs-keyword\">struct</span> {\n    LabelsHandler     <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span> <span class=\"hljs-string\">`json:\"labelsHandler,omitempty\"`</span>\n    FinalizersHandler []<span class=\"hljs-keyword\">string</span>          <span class=\"hljs-string\">`json:\"finalizersHandler,omitempty\"`</span>\n}\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n\n  <span class=\"hljs-comment\"># 通过 finalizer 定义 hook</span>\n  <span class=\"hljs-attr\">lifecycle:</span>\n    <span class=\"hljs-attr\">preDelete:</span>\n      <span class=\"hljs-attr\">finalizersHandler:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">example.io/unready-blocker</span>\n    <span class=\"hljs-attr\">inPlaceUpdate:</span>\n      <span class=\"hljs-attr\">finalizersHandler:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">example.io/unready-blocker</span>\n\n  <span class=\"hljs-comment\"># 或者也可以通过 label 定义</span>\n  <span class=\"hljs-attr\">lifecycle:</span>\n    <span class=\"hljs-attr\">inPlaceUpdate:</span>\n      <span class=\"hljs-attr\">labelsHandler:</span>\n        <span class=\"hljs-attr\">example.io/block-unready:</span> <span class=\"hljs-string\">\"true\"</span>\n</code></pre>\n<h4>流转示意</h4>\n<p><img src=\"/img/docs/cloneset-lifecycle.png\" alt=\"Lifecycle circulation\"></p>\n<ul>\n<li>当 CloneSet 删除一个 Pod（包括正常缩容和重建升级）时：\n<ul>\n<li>如果没有定义 lifecycle hook 或者 Pod 不符合 preDelete 条件，则直接删除</li>\n<li>否则，先只将 Pod 状态改为 <code>PreparingDelete</code>。等用户 controller 完成任务去掉 label/finalizer、Pod 不符合 preDelete 条件后，kruise 才执行 Pod 删除</li>\n<li>注意：<code>PreparingDelete</code> 状态的 Pod 处于删除阶段，不会被升级</li>\n</ul>\n</li>\n<li>当 CloneSet 原地升级一个 Pod 时：\n<ul>\n<li>升级之前，如果定义了 lifecycle hook 且 Pod 符合 inPlaceUpdate 条件，则将 Pod 状态改为 <code>PreparingUpdate</code></li>\n<li>等用户 controller 完成任务去掉 label/finalizer、Pod 不符合 inPlaceUpdate 条件后，kruise 将 Pod 状态改为 <code>Updating</code> 并开始升级</li>\n<li>升级完成后，如果定义了 lifecycle hook 且 Pod 不符合 inPlaceUpdate 条件，将 Pod 状态改为 <code>Updated</code></li>\n<li>等用户 controller 完成任务加上 label/finalizer、Pod 符合 inPlaceUpdate 条件后，kruise 将 Pod 状态改为 <code>Normal</code> 并判断为升级成功</li>\n</ul>\n</li>\n</ul>\n<p>关于从 <code>PreparingDelete</code> 回到 <code>Normal</code> 状态，从设计上是支持的（通过撤销指定删除），但我们一般不建议这种用法。由于 <code>PreparingDelete</code> 状态的 Pod 不会被升级，当回到 <code>Normal</code> 状态后可能立即再进入发布阶段，对于用户处理 hook 是一个难题。</p>\n<h4>另一种指定 Pod 删除的方式</h4>\n<p>前面介绍过，CloneSet 通过提供 <code>spec.scaleStrategy.podsToDelete</code> 字段来允许用户在缩小 replicas 的时候指定要删除的 Pod。\n但如果用户只是想删除某个 Pod 并让 CloneSet 重建，这种情况下修改 CloneSet 成本比较高，而用户直接删除 Pod 又无法触发 preDelete hook。</p>\n<p>因此我们又提供了一个 Pod 标签用于指定删除：<code>apps.kruise.io/specified-delete: true</code>。打了这个标签的 Pod，CloneSet 也视为需要删除，会先进入 <code>PreparingDelete</code>，待 lifecycle hook 完成后再删除。</p>\n<h4>用户 controller 逻辑示例</h4>\n<p>按上述例子，可以定义：</p>\n<ul>\n<li><code>example.io/unready-blocker</code> finalizer 作为 hook</li>\n<li><code>example.io/initialing</code> annotation 作为初始化标记</li>\n</ul>\n<p>在 CloneSet template 模板里带上这个字段：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps.kruise.io/v1alpha1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CloneSet</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">metadata:</span>\n      <span class=\"hljs-attr\">annotations:</span>\n        <span class=\"hljs-attr\">example.io/initialing:</span> <span class=\"hljs-string\">\"true\"</span>\n      <span class=\"hljs-attr\">finalizers:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">example.io/unready-blocker</span>\n  <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-attr\">lifecycle:</span>\n    <span class=\"hljs-attr\">preDelete:</span>\n      <span class=\"hljs-attr\">finalizersHandler:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">example.io/unready-blocker</span>\n    <span class=\"hljs-attr\">inPlaceUpdate:</span>\n      <span class=\"hljs-attr\">finalizersHandler:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">example.io/unready-blocker</span>\n</code></pre>\n<p>而后用户 controller 的逻辑如下：</p>\n<ul>\n<li>对于 <code>Normal</code> 状态的 Pod，如果 annotation 中有 <code>example.io/initialing: true</code> 并且 Pod status 中的 ready condition 为 True，则接入流量、去除这个 annotation</li>\n<li>对于 <code>PreparingDelete</code> 和 <code>PreparingUpdate</code> 状态的 Pod，切走流量，并去除 <code>example.io/unready-blocker</code> finalizer</li>\n<li>对于 <code>Updated</code> 状态的 Pod，接入流量，并打上 <code>example.io/unready-blocker</code> finalizer</li>\n</ul>\n",
  "link": "/zh-cn/docs/cloneset.html",
  "meta": {
    "title": "CloneSet"
  }
}